ideal layout:
action button: linked to particular action, shows if selected unit is capable of corresponding action, calls initial function when pressed
  ^ can_show and on_click logic should mostly be offloaded to action function to allow removing action-specific button classes
notification manager: manages notification queue, creates notifications, and manages what happens after one is removed - creations are requested by initial
  action function, and manager either creates it immediately if no notification exists or puts it in the queue if one does exist
action notifications: only a general action notification class - this class will manage the interface and non-initial action function calls
  When created, inserts interface collection above, places sibling ordered collection to the left, and populates ordered collection w/ dice/portraits
  When removed, recursively remove parent collection and member elements (think of how to handle this with removing self), alert notification manager, and call
    the correct action phase function
action function: Each action function exists in its own file, taking a controlling unit and action phase as input
  each action phase will call another function for that phase, and main action function will return whatever phase function returned
  phases:
      setup? - possible phase, would specify how to create a button linked to this action - lower priority
      can_show: Returns whether a button linked to the action should be able to be shown, usually related to what units are allowed to do its action
      on_click: Controls behavior when button linked to the action is clicked - locks player, and, if passes criteria, calls inital phase
      initial: Called by on_click, creates choice notification with option to proceed
      middle: Called by choice notification's proceed option, determines action result and creates rolling/in-progress notifications
      finish: Called by one of middle's notifications on removal (or init?), puts into effect all results of the function and unlocks player
Exceptions:
    Combat - special action with no can_show, on_click, or initial functionality - attacking or being attacked immediately enters middle
    Attack - Currently, attempting to move into enemy acts as on_click, movement confirmation is initial phase, and attempt_local_combat is middle phase, which 
        links to middle of combat - this logical flow should stay intact and should be one of the last actions converted

once this is all implemented, adding a new action type should only require creating the action file with the correct setup, can_show, on_click, initial,
  middle, and final phase functions - file will be scanned, and its setup will automatically be run and put into the program - it will contain all of its own
  "business logic" and interface setup instructions
  Should also consider shared functionality between different actions, with their very similar dice, promotions, and logical flows - this is probably best
      handled with a generic function that other functions will be variants of, or possibly an action_utility file with the relevant utility functions
currently, adding a new action type requires creating a new action_notification class, a new actor_display_button class, defining new choice buttons,
  setting up the action button in actor_display_label, and creating the unit's 3 action functions

Implementation phases:
1. (complete) Rework notification requests to be submitted with input dicts rather than function parameters
2. Rework notification manager and existing action notifications to make notification manager the only actor handling the notification queue
3. Rework notifications to manage their own interface collection with all peripheral interface elements (dice, portraits, etc.)
4. Implement changes for a single action type, ommitting the setup function - program should still run, but other actions may not worker
    - PR campaign would be a good candidate for this - action is extremely generic, with only action-specific functionality being in the result
    - changes involve moving the PR button's can_show and on_click functionality and the evangelist's start_PR, PR, and complete_PR functions to an
        action-specific file
5. Continue implementing changes for other action types, ending with exceptions
6. Automate setup with setup functions for each action type